import telebot
import requests
import time
import json
import os
import random
import string
from datetime import datetime, timedelta
from threading import Thread, Event, Lock

from flask import Flask, request

# --- C·∫•u h√¨nh Bot (ƒê·∫∂T TR·ª∞C TI·∫æP T·∫†I ƒê√ÇY) ---
# THAY TH·∫æ 'YOUR_BOT_TOKEN_HERE' B·∫∞NG TOKEN TH·∫¨T C·ª¶A B·∫†N
BOT_TOKEN = "7949117582:AAG-vTt2h_IEQpZ2TtlAIxjd_U9u3h_XLDc" 
# THAY TH·∫æ B·∫∞NG ID ADMIN TH·∫¨T C·ª¶A B·∫†N. C√≥ th·ªÉ c√≥ nhi·ªÅu ID, c√°ch nhau b·ªüi d·∫•u ph·∫©y.
ADMIN_IDS = [6915752059] # V√≠ d·ª•: [6915752059, 123456789]

DATA_FILE = 'user_data.json'
CAU_PATTERNS_FILE = 'cau_patterns.json'
CODES_FILE = 'codes.json'

# --- Kh·ªüi t·∫°o Flask App v√† Telegram Bot ---
app = Flask(__name__)
bot = telebot.TeleBot(BOT_TOKEN)

# Global flags v√† objects
bot_enabled = True
bot_disable_reason = "Kh√¥ng c√≥"
bot_disable_admin_id = None
prediction_stop_event = Event() # ƒê·ªÉ ki·ªÉm so√°t lu·ªìng d·ª± ƒëo√°n
bot_initialized = False # C·ªù ƒë·ªÉ ƒë·∫£m b·∫£o bot ch·ªâ ƒë∆∞·ª£c kh·ªüi t·∫°o m·ªôt l·∫ßn
bot_init_lock = Lock() # Kh√≥a ƒë·ªÉ tr√°nh race condition khi kh·ªüi t·∫°o

# Global sets for patterns and codes
CAU_XAU = set()
CAU_DEP = set()
GENERATED_CODES = {} # {code: {"value": 1, "type": "day", "used_by": null, "used_time": null}}

# --- Qu·∫£n l√Ω d·ªØ li·ªáu ng∆∞·ªùi d√πng, m·∫´u c·∫ßu v√† code ---
user_data = {}

def load_user_data():
    global user_data
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, 'r') as f:
            try:
                user_data = json.load(f)
            except json.JSONDecodeError:
                print(f"L·ªói ƒë·ªçc {DATA_FILE}. Kh·ªüi t·∫°o l·∫°i d·ªØ li·ªáu ng∆∞·ªùi d√πng.")
                user_data = {}
    else:
        user_data = {}
    print(f"Loaded {len(user_data)} user records from {DATA_FILE}")

def save_user_data(data):
    with open(DATA_FILE, 'w') as f:
        json.dump(data, f, indent=4)

def load_cau_patterns():
    global CAU_XAU, CAU_DEP
    if os.path.exists(CAU_PATTERNS_FILE):
        with open(CAU_PATTERNS_FILE, 'r') as f:
            try:
                data = json.load(f)
                CAU_DEP.update(data.get('dep', []))
                CAU_XAU.update(data.get('xau', []))
            except json.JSONDecodeError:
                print(f"L·ªói ƒë·ªçc {CAU_PATTERNS_FILE}. Kh·ªüi t·∫°o l·∫°i m·∫´u c·∫ßu.")
                CAU_DEP = set()
                CAU_XAU = set()
    else:
        CAU_DEP = set()
        CAU_XAU = set()
    print(f"Loaded {len(CAU_DEP)} dep patterns and {len(CAU_XAU)} xau patterns.")

def save_cau_patterns():
    with open(CAU_PATTERNS_FILE, 'w') as f:
        json.dump({'dep': list(CAU_DEP), 'xau': list(CAU_XAU)}, f, indent=4)

def load_codes():
    global GENERATED_CODES
    if os.path.exists(CODES_FILE):
        with open(CODES_FILE, 'r') as f:
            try:
                GENERATED_CODES = json.load(f)
            except json.JSONDecodeError:
                print(f"L·ªói ƒë·ªçc {CODES_FILE}. Kh·ªüi t·∫°o l·∫°i m√£ code.")
                GENERATED_CODES = {}
    else:
        GENERATED_CODES = {}
    print(f"Loaded {len(GENERATED_CODES)} codes from {CODES_FILE}")

def save_codes():
    with open(CODES_FILE, 'w') as f:
        json.dump(GENERATED_CODES, f, indent=4)

def is_admin(user_id):
    return user_id in ADMIN_IDS

def is_ctv(user_id):
    return is_admin(user_id) or (str(user_id) in user_data and user_data[str(user_id)].get('is_ctv'))

def check_subscription(user_id):
    user_id_str = str(user_id)
    if is_admin(user_id) or is_ctv(user_id):
        return True, "B·∫°n l√† Admin/CTV, quy·ªÅn truy c·∫≠p vƒ©nh vi·ªÖn."

    if user_id_str not in user_data or user_data[user_id_str].get('expiry_date') is None:
        return False, "‚ö†Ô∏è B·∫°n ch∆∞a ƒëƒÉng k√Ω ho·∫∑c t√†i kho·∫£n ch∆∞a ƒë∆∞·ª£c gia h·∫°n."

    expiry_date_str = user_data[user_id_str]['expiry_date']
    expiry_date = datetime.strptime(expiry_date_str, '%Y-%m-%d %H:%M:%S')

    if datetime.now() < expiry_date:
        remaining_time = expiry_date - datetime.now()
        days = remaining_time.days
        hours = remaining_time.seconds // 3600
        minutes = (remaining_time.seconds % 3600) // 60
        seconds = remaining_time.seconds % 60
        return True, f"‚úÖ T√†i kho·∫£n c·ªßa b·∫°n c√≤n h·∫°n ƒë·∫øn: `{expiry_date_str}` ({days} ng√†y {hours} gi·ªù {minutes} ph√∫t {seconds} gi√¢y)."
    else:
        return False, "‚ùå T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n."

# --- Logic d·ª± ƒëo√°n T√†i X·ªâu ---
def du_doan_theo_xi_ngau(dice_list):
    if not dice_list:
        return "ƒê·ª£i th√™m d·ªØ li·ªáu"
    d1, d2, d3 = dice_list[-1]
    total = d1 + d2 + d3

    result_list = []
    for d in [d1, d2, d3]:
        tmp = d + total
        if tmp in [4, 5]:
            tmp -= 4
        elif tmp >= 6:
            tmp -= 6
        result_list.append("T√†i" if tmp % 2 == 0 else "X·ªâu")

    return max(set(result_list), key=result_list.count)

def tinh_tai_xiu(dice):
    total = sum(dice)
    return "T√†i" if total >= 11 else "X·ªâu", total

# --- C·∫≠p nh·∫≠t m·∫´u c·∫ßu ƒë·ªông ---
def update_cau_patterns(new_cau, prediction_correct):
    global CAU_DEP, CAU_XAU
    if prediction_correct:
        CAU_DEP.add(new_cau)
        if new_cau in CAU_XAU:
            CAU_XAU.remove(new_cau)
    else:
        CAU_XAU.add(new_cau)
        if new_cau in CAU_DEP:
            CAU_DEP.remove(new_cau)
    save_cau_patterns()
    # print(f"ƒê√£ c·∫≠p nh·∫≠t m·∫´u c·∫ßu: C·∫ßu ƒë·∫πp: {len(CAU_DEP)}, C·∫ßu x·∫•u: {len(CAU_XAU)}")

def is_cau_xau(cau_str):
    return cau_str in CAU_XAU

def is_cau_dep(cau_str):
    return cau_str in CAU_DEP and cau_str not in CAU_XAU # ƒê·∫£m b·∫£o kh√¥ng tr√πng c·∫ßu x·∫•u

# --- L·∫•y d·ªØ li·ªáu t·ª´ API ---
def lay_du_lieu():
    try:
        response = requests.get("https://1.bot/GetNewLottery/LT_Taixiu")
        response.raise_for_status() # B√°o l·ªói n·∫øu status code l√† l·ªói HTTP
        data = response.json()
        if data.get("state") != 1:
            # print(f"API tr·∫£ v·ªÅ state kh√¥ng th√†nh c√¥ng: {data.get('state')}")
            return None
        return data.get("data")
    except requests.exceptions.RequestException as e:
        print(f"L·ªói khi l·∫•y d·ªØ li·ªáu t·ª´ API: {e}")
        return None
    except json.JSONDecodeError:
        print("L·ªói gi·∫£i m√£ JSON t·ª´ API. Ph·∫£n h·ªìi kh√¥ng ph·∫£i JSON h·ª£p l·ªá.")
        return None

# --- Logic ch√≠nh c·ªßa Bot d·ª± ƒëo√°n (ch·∫°y trong lu·ªìng ri√™ng) ---
def prediction_loop(stop_event: Event):
    last_id = None
    tx_history = []
    
    print("Prediction loop started.")
    while not stop_event.is_set():
        if not bot_enabled:
            # print(f"Bot d·ª± ƒëo√°n ƒëang t·∫°m d·ª´ng. L√Ω do: {bot_disable_reason}")
            time.sleep(10) # Ng·ªß l√¢u h∆°n khi bot b·ªã t·∫Øt
            continue

        data = lay_du_lieu()
        if not data:
            # print("‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ API ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.")
            time.sleep(5)
            continue

        issue_id = data.get("ID")
        expect = data.get("Expect")
        open_code = data.get("OpenCode")

        if not all([issue_id, expect, open_code]):
            # print("D·ªØ li·ªáu API kh√¥ng ƒë·∫ßy ƒë·ªß (thi·∫øu ID, Expect, ho·∫∑c OpenCode). B·ªè qua phi√™n n√†y.")
            time.sleep(5)
            continue

        if issue_id != last_id:
            try:
                dice = tuple(map(int, open_code.split(",")))
            except ValueError:
                print(f"L·ªói ph√¢n t√≠ch OpenCode: '{open_code}'. B·ªè qua phi√™n n√†y.")
                last_id = issue_id # V·∫´n c·∫≠p nh·∫≠t last_id ƒë·ªÉ kh√¥ng l·∫∑p l·∫°i l·ªói
                time.sleep(5)
                continue
            
            ket_qua_tx, tong = tinh_tai_xiu(dice)

            # L∆∞u l·ªãch s·ª≠ 5 phi√™n
            if len(tx_history) >= 5:
                tx_history.pop(0)
            tx_history.append("T" if ket_qua_tx == "T√†i" else "X")

            next_expect = str(int(expect) + 1).zfill(len(expect))
            du_doan = du_doan_theo_xi_ngau([dice])

            ly_do = ""
            current_cau = ""

            if len(tx_history) < 5:
                ly_do = "AI D·ª± ƒëo√°n theo x√≠ ng·∫ßu (ch∆∞a ƒë·ªß m·∫´u c·∫ßu)"
            else:
                current_cau = ''.join(tx_history)
                if is_cau_dep(current_cau):
                    ly_do = f"AI C·∫ßu ƒë·∫πp ({current_cau}) ‚Üí Gi·ªØ nguy√™n k·∫øt qu·∫£"
                elif is_cau_xau(current_cau):
                    du_doan = "X·ªâu" if du_doan == "T√†i" else "T√†i" # ƒê·∫£o chi·ªÅu
                    ly_do = f"AI C·∫ßu x·∫•u ({current_cau}) ‚Üí ƒê·∫£o chi·ªÅu k·∫øt qu·∫£"
                else:
                    ly_do = f"AI Kh√¥ng r√µ m·∫´u c·∫ßu ({current_cau}) ‚Üí D·ª± ƒëo√°n theo x√≠ ng·∫ßu"
            
            # C·∫≠p nh·∫≠t m·∫´u c·∫ßu d·ª±a tr√™n k·∫øt qu·∫£ th·ª±c t·∫ø
            if len(tx_history) >= 5:
                prediction_correct = (du_doan == "T√†i" and ket_qua_tx == "T√†i") or \
                                     (du_doan == "X·ªâu" and ket_qua_tx == "X·ªâu")
                update_cau_patterns(current_cau, prediction_correct)

            # G·ª≠i tin nh·∫Øn d·ª± ƒëo√°n t·ªõi t·∫•t c·∫£ ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p
            for user_id_str, user_info in list(user_data.items()): # D√πng list() ƒë·ªÉ tr√°nh l·ªói khi user_data thay ƒë·ªïi
                user_id = int(user_id_str)
                is_sub, sub_message = check_subscription(user_id)
                if is_sub:
                    try:
                        prediction_message = (
                            "üéÆ **K·∫æT QU·∫¢ PHI√äN HI·ªÜN T·∫†I** üéÆ\n"
                            f"Phi√™n: `{expect}` | K·∫øt qu·∫£: **{ket_qua_tx}** (T·ªïng: **{tong}**)\n\n"
                            f"**D·ª± ƒëo√°n cho phi√™n ti·∫øp theo:**\n"
                            f"üî¢ Phi√™n: `{next_expect}`\n"
                            f"ü§ñ D·ª± ƒëo√°n: **{du_doan}**\n"
                            f"üìå L√Ω do: _{ly_do}_\n"
                            f"‚ö†Ô∏è **H√£y ƒë·∫∑t c∆∞·ª£c s·ªõm tr∆∞·ªõc khi phi√™n k·∫øt th√∫c!**"
                        )
                        bot.send_message(user_id, prediction_message, parse_mode='Markdown')
                    except telebot.apihelper.ApiTelegramException as e:
                        if "bot was blocked by the user" in str(e) or "user is deactivated" in str(e):
                            print(f"Ng∆∞·ªùi d√πng {user_id} ƒë√£ ch·∫∑n bot ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a. C√≥ th·ªÉ x√≥a kh·ªèi danh s√°ch theo d√µi.")
                            # Optional: Remove user from user_data if blocked
                            # del user_data[user_id_str] 
                            # save_user_data(user_data)
                        else:
                            print(f"L·ªói g·ª≠i tin nh·∫Øn cho user {user_id}: {e}")
                    except Exception as e:
                        print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i tin nh·∫Øn cho user {user_id}: {e}")

            print("-" * 50)
            print("üéÆ K·∫øt qu·∫£ phi√™n hi·ªán t·∫°i: {} (T·ªïng: {})".format(ket_qua_tx, tong))
            print("üî¢ Phi√™n: {} ‚Üí {}".format(expect, next_expect))
            print("ü§ñ D·ª± ƒëo√°n: {}".format(du_doan))
            print("üìå L√Ω do: {}".format(ly_do))
            print("‚ö†Ô∏è H√£y ƒë·∫∑t c∆∞·ª£c s·ªõm tr∆∞·ªõc khi phi√™n k·∫øt th√∫c!")
            print("-" * 50)

            last_id = issue_id

        time.sleep(5) # ƒê·ª£i 5 gi√¢y tr∆∞·ªõc khi ki·ªÉm tra phi√™n m·ªõi
    print("Prediction loop stopped.")

# --- X·ª≠ l√Ω l·ªánh Telegram ---

@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = str(message.chat.id)
    username = message.from_user.username or message.from_user.first_name
    
    if user_id not in user_data:
        user_data[user_id] = {
            'username': username,
            'expiry_date': None,
            'is_ctv': False
        }
        save_user_data(user_data)
        bot.reply_to(message, 
                     "Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi **BOT D·ª∞ ƒêO√ÅN T√ÄI X·ªàU SUNWIN**!\n"
                     "H√£y d√πng l·ªánh /help ƒë·ªÉ xem danh s√°ch c√°c l·ªánh h·ªó tr·ª£.", 
                     parse_mode='Markdown')
    else:
        user_data[user_id]['username'] = username # C·∫≠p nh·∫≠t username n·∫øu c√≥ thay ƒë·ªïi
        save_user_data(user_data)
        bot.reply_to(message, "B·∫°n ƒë√£ kh·ªüi ƒë·ªông bot r·ªìi. D√πng /help ƒë·ªÉ xem c√°c l·ªánh.")

@bot.message_handler(commands=['help'])
def show_help(message):
    help_text = (
        "ü§ñ **DANH S√ÅCH L·ªÜNH H·ªñ TR·ª¢** ü§ñ\n\n"
        "**L·ªánh ng∆∞·ªùi d√πng:**\n"
        "üî∏ `/start`: Kh·ªüi ƒë·ªông bot v√† th√™m b·∫°n v√†o h·ªá th·ªëng.\n"
        "üî∏ `/help`: Hi·ªÉn th·ªã danh s√°ch c√°c l·ªánh.\n"
        "üî∏ `/support`: Th√¥ng tin h·ªó tr·ª£ Admin.\n"
        "üî∏ `/gia`: Xem b·∫£ng gi√° d·ªãch v·ª•.\n"
        "üî∏ `/gopy <n·ªôi dung>`: G·ª≠i g√≥p √Ω/b√°o l·ªói cho Admin.\n"
        "üî∏ `/nap`: H∆∞·ªõng d·∫´n n·∫°p ti·ªÅn.\n"
        "üî∏ `/dudoan`: B·∫Øt ƒë·∫ßu nh·∫≠n d·ª± ƒëo√°n t·ª´ bot.\n"
        "üî∏ `/maucau`: Hi·ªÉn th·ªã c√°c m·∫´u c·∫ßu bot ƒë√£ thu th·∫≠p (x·∫•u/ƒë·∫πp).\n"
        "üî∏ `/code <m√£_code>`: Nh·∫≠p m√£ code ƒë·ªÉ gia h·∫°n t√†i kho·∫£n.\n\n"
    )
    
    if is_ctv(message.chat.id):
        help_text += (
            "**L·ªánh Admin/CTV:**\n"
            "üîπ `/full <id>`: Xem th√¥ng tin ng∆∞·ªùi d√πng (ƒë·ªÉ tr·ªëng ID ƒë·ªÉ xem c·ªßa b·∫°n).\n"
            "üîπ `/giahan <id> <s·ªë ng√†y/gi·ªù>`: Gia h·∫°n t√†i kho·∫£n ng∆∞·ªùi d√πng. V√≠ d·ª•: `/giahan 12345 1 ng√†y` ho·∫∑c `/giahan 12345 24 gi·ªù`.\n\n"
        )
    
    if is_admin(message.chat.id):
        help_text += (
            "**L·ªánh Admin Ch√≠nh:**\n"
            "üëë `/ctv <id>`: Th√™m ng∆∞·ªùi d√πng l√†m CTV.\n"
            "üëë `/xoactv <id>`: X√≥a ng∆∞·ªùi d√πng kh·ªèi CTV.\n"
            "üëë `/tb <n·ªôi dung>`: G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng.\n"
            "üëë `/tatbot <l√Ω do>`: T·∫Øt m·ªçi ho·∫°t ƒë·ªông c·ªßa bot d·ª± ƒëo√°n.\n"
            "üëë `/mokbot`: M·ªü l·∫°i ho·∫°t ƒë·ªông c·ªßa bot d·ª± ƒëo√°n.\n"
            "üëë `/taocode <gi√° tr·ªã> <ng√†y/gi·ªù> <s·ªë l∆∞·ª£ng>`: T·∫°o m√£ code gia h·∫°n. V√≠ d·ª•: `/taocode 1 ng√†y 5` (t·∫°o 5 code 1 ng√†y).\n"
        )
    
    bot.reply_to(message, help_text, parse_mode='Markdown')

@bot.message_handler(commands=['support'])
def show_support(message):
    bot.reply_to(message, 
        "ƒê·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£, vui l√≤ng li√™n h·ªá Admin:\n"
        "@heheviptool ho·∫∑c @Besttaixiu999"
    )

@bot.message_handler(commands=['gia'])
def show_price(message):
    price_text = (
        "üìä **BOT SUNWIN XIN TH√îNG B√ÅO B·∫¢NG GI√Å SUN BOT** üìä\n\n"
        "üí∏ **20k**: 1 Ng√†y\n"
        "üí∏ **50k**: 1 Tu·∫ßn\n"
        "üí∏ **80k**: 2 Tu·∫ßn\n"
        "üí∏ **130k**: 1 Th√°ng\n\n"
        "ü§ñ BOT SUN T·ªà L·ªá **85-92%**\n"
        "‚è±Ô∏è ƒê·ªåC 24/24\n\n"
        "Vui L√≤ng ib @heheviptool ho·∫∑c @Besttaixiu999 ƒê·ªÉ Gia H·∫°n"
    )
    bot.reply_to(message, price_text, parse_mode='Markdown')

@bot.message_handler(commands=['gopy'])
def send_feedback(message):
    feedback_text = telebot.util.extract_arguments(message.text)
    if not feedback_text:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p n·ªôi dung g√≥p √Ω. V√≠ d·ª•: `/gopy Bot d·ª± ƒëo√°n r·∫•t chu·∫©n!`", parse_mode='Markdown')
        return
    
    admin_id = ADMIN_IDS[0] # G·ª≠i cho Admin ƒë·∫ßu ti√™n trong danh s√°ch
    user_name = message.from_user.username or message.from_user.first_name
    bot.send_message(admin_id, 
                     f"üì¢ **G√ìP √ù M·ªöI T·ª™ NG∆Ø·ªúI D√ôNG** üì¢\n\n"
                     f"**ID:** `{message.chat.id}`\n"
                     f"**T√™n:** @{user_name}\n\n"
                     f"**N·ªôi dung:**\n`{feedback_text}`",
                     parse_mode='Markdown')
    bot.reply_to(message, "C·∫£m ∆°n b·∫°n ƒë√£ g·ª≠i g√≥p √Ω! Admin ƒë√£ nh·∫≠n ƒë∆∞·ª£c.")

@bot.message_handler(commands=['nap'])
def show_deposit_info(message):
    user_id = message.chat.id
    deposit_text = (
        "‚öúÔ∏è **N·∫†P TI·ªÄN MUA L∆Ø·ª¢T** ‚öúÔ∏è\n\n"
        "ƒê·ªÉ mua l∆∞·ª£t, vui l√≤ng chuy·ªÉn kho·∫£n ƒë·∫øn:\n"
        "- Ng√¢n h√†ng: **MB BANK**\n"
        "- S·ªë t√†i kho·∫£n: **0939766383**\n"
        "- T√™n ch·ªß TK: **Nguyen Huynh Nhut Quang**\n\n"
        "**N·ªòI DUNG CHUY·ªÇN KHO·∫¢N (QUAN TR·ªåNG):**\n"
        "`mua luot {user_id}`\n\n"
        f"‚ùóÔ∏è N·ªôi dung b·∫Øt bu·ªôc c·ªßa b·∫°n l√†:\n"
        f"`mua luot {user_id}`\n\n"
        "(Vui l√≤ng sao ch√©p ƒë√∫ng n·ªôi dung tr√™n ƒë·ªÉ ƒë∆∞·ª£c c·ªông l∆∞·ª£t t·ª± ƒë·ªông)\n"
        "Sau khi chuy·ªÉn kho·∫£n, vui l√≤ng ch·ªù 1-2 ph√∫t. N·∫øu c√≥ s·ª± c·ªë, h√£y d√πng l·ªánh /support."
    )
    bot.reply_to(message, deposit_text, parse_mode='Markdown')

@bot.message_handler(commands=['dudoan'])
def start_prediction_command(message):
    user_id = message.chat.id
    is_sub, sub_message = check_subscription(user_id)
    
    if not is_sub:
        bot.reply_to(message, sub_message + "\nVui l√≤ng li√™n h·ªá Admin @heheviptool ho·∫∑c @Besttaixiu999 ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.", parse_mode='Markdown')
        return
    
    if not bot_enabled:
        bot.reply_to(message, f"‚ùå Bot d·ª± ƒëo√°n hi·ªán ƒëang t·∫°m d·ª´ng b·ªüi Admin. L√Ω do: `{bot_disable_reason}`", parse_mode='Markdown')
        return

    bot.reply_to(message, "‚úÖ B·∫°n ƒëang c√≥ quy·ªÅn truy c·∫≠p. Bot s·∫Ω t·ª± ƒë·ªông g·ª≠i d·ª± ƒëo√°n c√°c phi√™n m·ªõi nh·∫•t t·∫°i ƒë√¢y.")

@bot.message_handler(commands=['maucau'])
def show_cau_patterns(message):
    if not is_ctv(message.chat.id): # Ch·ªâ Admin/CTV m·ªõi ƒë∆∞·ª£c xem m·∫´u c·∫ßu chi ti·∫øt
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    dep_patterns = "\n".join(sorted(list(CAU_DEP))) if CAU_DEP else "Kh√¥ng c√≥"
    xau_patterns = "\n".join(sorted(list(CAU_XAU))) if CAU_XAU else "Kh√¥ng c√≥"

    pattern_text = (
        "üìö **C√ÅC M·∫™U C·∫¶U ƒê√É THU TH·∫¨P** üìö\n\n"
        "**üü¢ C·∫ßu ƒê·∫πp:**\n"
        f"```\n{dep_patterns}\n```\n\n"
        "**üî¥ C·∫ßu X·∫•u:**\n"
        f"```\n{xau_patterns}\n```\n"
        "*(C√°c m·∫´u c·∫ßu n√†y ƒë∆∞·ª£c bot t·ª± ƒë·ªông h·ªçc h·ªèi theo th·ªùi gian.)*"
    )
    bot.reply_to(message, pattern_text, parse_mode='Markdown')

@bot.message_handler(commands=['code'])
def use_code(message):
    code_str = telebot.util.extract_arguments(message.text)
    user_id = str(message.chat.id)

    if not code_str:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p m√£ code. V√≠ d·ª•: `/code ABCXYZ`", parse_mode='Markdown')
        return
    
    if code_str not in GENERATED_CODES:
        bot.reply_to(message, "‚ùå M√£ code kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n.")
        return

    code_info = GENERATED_CODES[code_str]
    if code_info.get('used_by') is not None:
        bot.reply_to(message, "‚ùå M√£ code n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªìi.")
        return

    # Apply extension
    current_expiry_str = user_data.get(user_id, {}).get('expiry_date')
    if current_expiry_str:
        current_expiry_date = datetime.strptime(current_expiry_str, '%Y-%m-%d %H:%M:%S')
        # If current expiry is in the past, start from now
        if datetime.now() > current_expiry_date:
            new_expiry_date = datetime.now()
        else:
            new_expiry_date = current_expiry_date
    else:
        new_expiry_date = datetime.now() # Start from now if no previous expiry

    value = code_info['value']
    if code_info['type'] == 'ng√†y':
        new_expiry_date += timedelta(days=value)
    elif code_info['type'] == 'gi·ªù':
        new_expiry_date += timedelta(hours=value)
    
    user_data.setdefault(user_id, {})['expiry_date'] = new_expiry_date.strftime('%Y-%m-%d %H:%M:%S')
    user_data[user_id]['username'] = message.from_user.username or message.from_user.first_name
    
    GENERATED_CODES[code_str]['used_by'] = user_id
    GENERATED_CODES[code_str]['used_time'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    save_user_data(user_data)
    save_codes()

    bot.reply_to(message, 
                 f"üéâ B·∫°n ƒë√£ ƒë·ªïi m√£ code th√†nh c√¥ng! T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m **{value} {code_info['type']}**.\n"
                 f"Ng√†y h·∫øt h·∫°n m·ªõi: `{user_expiry_date(user_id)}`", 
                 parse_mode='Markdown')

def user_expiry_date(user_id):
    if str(user_id) in user_data and user_data[str(user_id)].get('expiry_date'):
        return user_data[str(user_id)]['expiry_date']
    return "Kh√¥ng c√≥"

# --- L·ªánh Admin/CTV ---
@bot.message_handler(commands=['full'])
def get_user_info(message):
    if not is_ctv(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    target_user_id_str = str(message.chat.id)
    if args and args[0].isdigit():
        target_user_id_str = args[0]
    
    if target_user_id_str not in user_data:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y th√¥ng tin cho ng∆∞·ªùi d√πng ID `{target_user_id_str}`.")
        return

    user_info = user_data[target_user_id_str]
    expiry_date_str = user_info.get('expiry_date', 'Kh√¥ng c√≥')
    username = user_info.get('username', 'Kh√¥ng r√µ')
    is_ctv_status = "C√≥" if is_ctv(int(target_user_id_str)) else "Kh√¥ng"

    info_text = (
        f"**TH√îNG TIN NG∆Ø·ªúI D√ôNG**\n"
        f"**ID:** `{target_user_id_str}`\n"
        f"**T√™n:** @{username}\n"
        f"**Ng√†y h·∫øt h·∫°n:** `{expiry_date_str}`\n"
        f"**L√† CTV/Admin:** {is_ctv_status}"
    )
    bot.reply_to(message, info_text, parse_mode='Markdown')

@bot.message_handler(commands=['giahan'])
def extend_subscription(message):
    if not is_ctv(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if len(args) != 3 or not args[0].isdigit() or not args[1].isdigit() or args[2].lower() not in ['ng√†y', 'gi·ªù']:
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/giahan <id_nguoi_dung> <s·ªë_l∆∞·ª£ng> <ng√†y/gi·ªù>`\n"
                              "V√≠ d·ª•: `/giahan 12345 1 ng√†y` ho·∫∑c `/giahan 12345 24 gi·ªù`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    value = int(args[1])
    unit = args[2].lower() # 'ng√†y' or 'gi·ªù'
    
    if target_user_id_str not in user_data:
        user_data[target_user_id_str] = {
            'username': "UnknownUser",
            'expiry_date': None,
            'is_ctv': False
        }
        bot.send_message(message.chat.id, f"ƒê√£ t·∫°o t√†i kho·∫£n m·ªõi cho user ID `{target_user_id_str}`.")

    current_expiry_str = user_data[target_user_id_str].get('expiry_date')
    if current_expiry_str:
        current_expiry_date = datetime.strptime(current_expiry_str, '%Y-%m-%d %H:%M:%S')
        if datetime.now() > current_expiry_date:
            new_expiry_date = datetime.now()
        else:
            new_expiry_date = current_expiry_date
    else:
        new_expiry_date = datetime.now() # Start from now if no previous expiry

    if unit == 'ng√†y':
        new_expiry_date += timedelta(days=value)
    elif unit == 'gi·ªù':
        new_expiry_date += timedelta(hours=value)
    
    user_data[target_user_id_str]['expiry_date'] = new_expiry_date.strftime('%Y-%m-%d %H:%M:%S')
    save_user_data(user_data)
    
    bot.reply_to(message, 
                 f"ƒê√£ gia h·∫°n th√†nh c√¥ng cho user ID `{target_user_id_str}` th√™m **{value} {unit}**.\n"
                 f"Ng√†y h·∫øt h·∫°n m·ªõi: `{user_data[target_user_id_str]['expiry_date']}`",
                 parse_mode='Markdown')
    
    try:
        bot.send_message(int(target_user_id_str), 
                         f"üéâ T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m **{value} {unit}** b·ªüi Admin/CTV!\n"
                         f"Ng√†y h·∫øt h·∫°n m·ªõi c·ªßa b·∫°n l√†: `{user_data[target_user_id_str]['expiry_date']}`",
                         parse_mode='Markdown')
    except telebot.apihelper.ApiTelegramException as e:
        if "bot was blocked by the user" in str(e):
            print(f"Kh√¥ng th·ªÉ th√¥ng b√°o gia h·∫°n cho user {target_user_id_str}: Ng∆∞·ªùi d√πng ƒë√£ ch·∫∑n bot.")
        else:
            print(f"Kh√¥ng th·ªÉ th√¥ng b√°o gia h·∫°n cho user {target_user_id_str}: {e}")

# --- L·ªánh Admin Ch√≠nh ---
@bot.message_handler(commands=['ctv'])
def add_ctv(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/ctv <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str not in user_data:
        user_data[target_user_id_str] = {
            'username': "UnknownUser",
            'expiry_date': None,
            'is_ctv': True
        }
    else:
        user_data[target_user_id_str]['is_ctv'] = True
    
    save_user_data(user_data)
    bot.reply_to(message, f"ƒê√£ c·∫•p quy·ªÅn CTV cho user ID `{target_user_id_str}`.")
    try:
        bot.send_message(int(target_user_id_str), "üéâ B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn CTV!")
    except Exception:
        pass

@bot.message_handler(commands=['xoactv'])
def remove_ctv(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if not args or not args[0].isdigit():
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•: `/xoactv <id_nguoi_dung>`", parse_mode='Markdown')
        return
    
    target_user_id_str = args[0]
    if target_user_id_str in user_data:
        user_data[target_user_id_str]['is_ctv'] = False
        save_user_data(user_data)
        bot.reply_to(message, f"ƒê√£ x√≥a quy·ªÅn CTV c·ªßa user ID `{target_user_id_str}`.")
        try:
            bot.send_message(int(target_user_id_str), "‚ùå Quy·ªÅn CTV c·ªßa b·∫°n ƒë√£ b·ªã g·ª° b·ªè.")
        except Exception:
            pass
    else:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng c√≥ ID `{target_user_id_str}`.")

@bot.message_handler(commands=['tb'])
def send_broadcast(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    broadcast_text = telebot.util.extract_arguments(message.text)
    if not broadcast_text:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o. V√≠ d·ª•: `/tb Bot s·∫Ω b·∫£o tr√¨ v√†o 2h s√°ng mai.`", parse_mode='Markdown')
        return
    
    success_count = 0
    fail_count = 0
    for user_id_str in list(user_data.keys()):
        try:
            bot.send_message(int(user_id_str), f"üì¢ **TH√îNG B√ÅO T·ª™ ADMIN** üì¢\n\n{broadcast_text}", parse_mode='Markdown')
            success_count += 1
            time.sleep(0.1) # Tr√°nh b·ªã rate limit
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o cho user {user_id_str}: {e}")
            fail_count += 1
            if "bot was blocked by the user" in str(e) or "user is deactivated" in str(e):
                print(f"Ng∆∞·ªùi d√πng {user_id_str} ƒë√£ ch·∫∑n bot ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a. C√≥ th·ªÉ x√≥a kh·ªèi user_data.")
                # Optional: del user_data[user_id_str] 
        except Exception as e:
            print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i th√¥ng b√°o cho user {user_id_str}: {e}")
            fail_count += 1
            
    bot.reply_to(message, f"ƒê√£ g·ª≠i th√¥ng b√°o ƒë·∫øn {success_count} ng∆∞·ªùi d√πng. Th·∫•t b·∫°i: {fail_count}.")
    save_user_data(user_data) # L∆∞u l·∫°i n·∫øu c√≥ user b·ªã x√≥a

@bot.message_handler(commands=['tatbot'])
def disable_bot_command(message):
    global bot_enabled, bot_disable_reason, bot_disable_admin_id
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    reason = telebot.util.extract_arguments(message.text)
    if not reason:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p l√Ω do t·∫Øt bot. V√≠ d·ª•: `/tatbot Bot ƒëang b·∫£o tr√¨.`", parse_mode='Markdown')
        return

    bot_enabled = False
    bot_disable_reason = reason
    bot_disable_admin_id = message.chat.id
    bot.reply_to(message, f"‚úÖ Bot d·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c t·∫Øt b·ªüi Admin `{message.from_user.username or message.from_user.first_name}`.\nL√Ω do: `{reason}`", parse_mode='Markdown')
    
    # Optionally notify all users
    # for user_id_str in list(user_data.keys()):
    #     try:
    #         bot.send_message(int(user_id_str), f"üì¢ **TH√îNG B√ÅO QUAN TR·ªåNG:** Bot d·ª± ƒëo√°n t·∫°m th·ªùi d·ª´ng ho·∫°t ƒë·ªông.\nL√Ω do: {reason}\nVui l√≤ng ch·ªù th√¥ng b√°o m·ªü l·∫°i.", parse_mode='Markdown')
    #     except Exception:
    #         pass

@bot.message_handler(commands=['mokbot'])
def enable_bot_command(message):
    global bot_enabled, bot_disable_reason, bot_disable_admin_id
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    if bot_enabled:
        bot.reply_to(message, "Bot d·ª± ƒëo√°n ƒë√£ v√† ƒëang ho·∫°t ƒë·ªông r·ªìi.")
        return

    bot_enabled = True
    bot_disable_reason = "Kh√¥ng c√≥"
    bot_disable_admin_id = None
    bot.reply_to(message, "‚úÖ Bot d·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c m·ªü l·∫°i b·ªüi Admin.")
    
    # Optionally notify all users
    # for user_id_str in list(user_data.keys()):
    #     try:
    #         bot.send_message(int(user_id_str), "üéâ **TH√îNG B√ÅO:** Bot d·ª± ƒëo√°n ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i!.", parse_mode='Markdown')
    #     except Exception:
    #         pass

@bot.message_handler(commands=['taocode'])
def generate_code_command(message):
    if not is_admin(message.chat.id):
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return
    
    args = telebot.util.extract_arguments(message.text).split()
    if len(args) < 2 or len(args) > 3: # Gi√° tr·ªã, ƒë∆°n v·ªã, s·ªë l∆∞·ª£ng (t√πy ch·ªçn)
        bot.reply_to(message, "C√∫ ph√°p sai. V√≠ d·ª•:\n"
                              "`/taocode <gi√°_tr·ªã> <ng√†y/gi·ªù> <s·ªë_l∆∞·ª£ng>`\n"
                              "V√≠ d·ª•: `/taocode 1 ng√†y 5` (t·∫°o 5 code 1 ng√†y)\n"
                              "Ho·∫∑c: `/taocode 24 gi·ªù` (t·∫°o 1 code 24 gi·ªù)", parse_mode='Markdown')
        return
    
    try:
        value = int(args[0])
        unit = args[1].lower()
        quantity = int(args[2]) if len(args) == 3 else 1 # M·∫∑c ƒë·ªãnh t·∫°o 1 code n·∫øu kh√¥ng c√≥ s·ªë l∆∞·ª£ng
        
        if unit not in ['ng√†y', 'gi·ªù']:
            bot.reply_to(message, "ƒê∆°n v·ªã kh√¥ng h·ª£p l·ªá. Ch·ªâ ch·∫•p nh·∫≠n `ng√†y` ho·∫∑c `gi·ªù`.", parse_mode='Markdown')
            return
        if value <= 0 or quantity <= 0:
            bot.reply_to(message, "Gi√° tr·ªã ho·∫∑c s·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0.", parse_mode='Markdown')
            return

        generated_codes_list = []
        for _ in range(quantity):
            new_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8)) # 8 k√Ω t·ª± ng·∫´u nhi√™n
            GENERATED_CODES[new_code] = {
                "value": value,
                "type": unit,
                "used_by": None,
                "used_time": None
            }
            generated_codes_list.append(new_code)
        
        save_codes()
        
        response_text = f"‚úÖ ƒê√£ t·∫°o th√†nh c√¥ng {quantity} m√£ code gia h·∫°n **{value} {unit}**:\n\n"
        response_text += "\n".join([f"`{code}`" for code in generated_codes_list])
        response_text += "\n\n_(C√°c m√£ n√†y ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng)_"
        
        bot.reply_to(message, response_text, parse_mode='Markdown')

    except ValueError:
        bot.reply_to(message, "Gi√° tr·ªã ho·∫∑c s·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë nguy√™n.", parse_mode='Markdown')
    except Exception as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫°o code: {e}", parse_mode='Markdown')


# --- Flask Routes cho Keep-Alive ---
@app.route('/')
def home():
    return "Bot is alive and running!"

@app.route('/health')
def health_check():
    return "OK", 200

# --- Kh·ªüi t·∫°o bot v√† c√°c lu·ªìng khi Flask app kh·ªüi ƒë·ªông ---
@app.before_request
def start_bot_threads():
    global bot_initialized
    with bot_init_lock:
        if not bot_initialized:
            print("Initializing bot and prediction threads...")
            # Load initial data
            load_user_data()
            load_cau_patterns()
            load_codes()

            # Start prediction loop in a separate thread
            prediction_thread = Thread(target=prediction_loop, args=(prediction_stop_event,))
            prediction_thread.daemon = True
            prediction_thread.start()
            print("Prediction loop thread started.")

            # Start bot polling in a separate thread
            # Use bot.infinity_polling() for robust polling
            polling_thread = Thread(target=bot.infinity_polling, kwargs={'none_stop': True})
            polling_thread.daemon = True
            polling_thread.start()
            print("Telegram bot polling thread started.")
            
            bot_initialized = True

# --- ƒêi·ªÉm kh·ªüi ch·∫°y ch√≠nh cho Gunicorn/Render ---
if __name__ == '__main__':
    # When running locally, ensure threads are started
    # For Render, gunicorn will call the Flask app, and @app.before_request will handle initialization
    # No need to call app.run() directly if Gunicorn is used as main entry point
    port = int(os.environ.get('PORT', 5000))
    print(f"Starting Flask app locally on port {port}")
    app.run(host='0.0.0.0', port=port, debug=True)

